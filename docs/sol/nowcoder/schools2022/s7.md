### I:[Suffix Sort](https://ac.nowcoder.com/acm/contest/33192/I)
#### LyFive
##### 标签
SA;ST表;排序

##### 题意
对于一个字符串$str$根据每一种字符第一次出现的顺序映射$a...z$，如$dabccd$映射为$abcdda$
现给定一个字符串$S$求其所有后缀$S[i:]=S_i...S_n$按照此规则进行排序的序列。
##### 思路
若不考虑规则，我们能发现排序可以直接使用$SA$求得$SA$数组。但通过规则变形后，两个相邻的后缀可能完全不相同，因此不能浅显使用$SA$进行排序。考虑字符串排序规则，对于两个字符串$A,B$若$A > B$则一定存在一个位置$p$使得$A_p > B_p$，为此可以将问题转化为对于两个字符串如何快速的找到位置$p$。
对于两个字符串我们通过比较每个字符的位置集合找到最小失配位置$p$，即所求的$p$。假设$S[i:]$中出现的第$k$个字符在$S[i:]$中出现的位置分别是${a_1,a_2,...,a_p,...}$，$S[j:]$中出现的第$k$个字符在$S[j:]$中出现的位置分别是${b_1,b_2,...,b_p,...}$那么在第$k$个字符的第$p$次出现位置还不失配的充要条件就是$a_1 - i= b_1 - j,a_2 - a_1 = b_2 - b_1 ,...,a_p - a_{p-1} = b_p - b_{p-1}$。因此对于位置我们可以通过构造差分数组，得到相对位置关系，再使用$SA$对差分数组进行排序利用$SA$中的$H$数组性质，构造$ST$表$O(1)$查询$H[rank[i],rank[j]]$即对于差分数组$i,j$后缀的最长公共前缀长度。为此只需要特殊比较第一个位置，利用最长公共前缀长度便可以快速查询对于第$k$个字符的失配位置，最终比较$a..z$所有字符的失配位置取最小指即可得到所求$p$。
对于差分数组$a$，根据不同字符构造26个数组进行合并，并构造$dp$数组，存储每一个后缀中字符映射关系，$pos$数组存储字符串后缀$S[i:]$起始位置对应差分数组$a$的位置。最终用$st$表对$H$数组进行构造。
##### 代码
??? note "参考代码"
    ```cpp
    --8<-- "docs/sol/code/nowcoder/schools2022_7_I.cpp"
    ```

### J:[Melborp Elcissalc](https://ac.nowcoder.com/acm/contest/33192/J)

##### 标签

##### 题意

##### 思路

### K:[Great Party](https://ac.nowcoder.com/acm/contest/33192/K)

##### 标签

##### 题意

##### 思路

