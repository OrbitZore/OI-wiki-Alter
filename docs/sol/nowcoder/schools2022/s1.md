### C:[Grab the Seat!](https://ac.nowcoder.com/acm/contest/33186/C)



***
### I:[Chiitoitsu](https://ac.nowcoder.com/acm/contest/33186/I)
#### LyFive
**题意**：牌库总共34×4张牌，起手摸13张。玩家每次摸一张牌丢一张牌，直到摸到恰好凑成7对牌后胜利。现求最优策略到达胜利所需摸牌数的期望。

**思路**：不难发现最优策略就是保留手上的单牌，若摸一张不是手上的单牌就丢掉，否则就保留。现设$dp[i][j]$为还缺$i$个对子，牌库还剩下$j$张牌获胜的期望。基于此，不难发现若缺$i$个对子，则手中已有$7-i$个对子，剩下$13 - 2(7-i)=2i-1$张单牌。考虑当前$i,j$状态下摸一张牌，那么这张牌是需要的单牌的概率应该为$p_v = \frac{3(2i-1)}{j}$，不是则为$p_f = 1-\frac{3(2i-1)}{j}$，每次摸牌牌库都会减少1。
因此得到递推式：$$dp[i][j] = dp[i-1][j-1]*p_v + dp[i][j-1]*p_f$$最终判断每次输入有多少个对子$cnt$输出$dp[7 - cnt][123]$即可。

**Code**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const LL mod = 1e9 + 7;
const LL N = 2e5 + 100;

LL t, n, m, x, y, k;
LL dp[8][136]; // 还缺i个对子，牌堆还有j张牌获胜的期望
LL inv[136];
LL ksm(LL x, LL y)
{
    if (y == 0)
        return 1;
    if (y == 1)
        return x % mod;
    LL as = ksm(x, y / 2);
    if (y % 2)
        return as * as % mod * x % mod;
    return as * as % mod;
}

LL mint(LL x)
{
    return x % mod;
}
void init()
{
    for (int i = 1; i < 136; i++)
    {
        inv[i] = ksm(i, mod - 2);
    }
    for (int i = 1; i <= 7; i++)
    {
        for (int j = i; j <= 123; j++)
        {
            dp[i][j] = mint(dp[i - 1][j - 1] + 1) * mint((6 * i - 3) * inv[j]) % mod +
                       mint(dp[i][j - 1] + 1) * mint((j - 6 * i + 3) * inv[j]) % mod;
            dp[i][j] %= mod;
        }
        // cout << dp[i][123] << endl;
    }
}

string s[13];
void solve()
{
    char x[3];

    for (int i = 0; i < 13; i++)
    {
        scanf("%2s", x);
        swap(x[0], x[1]);
        s[i] = x;
    }
    sort(s, s + 13);
    int cnt = 0;
    for (int i = 1; i < 13; i++)
        if (s[i] == s[i - 1])
            cnt++;

    cout << dp[7 - cnt][123] << "\n";
}

int main()
{
    init();
    cin >> t;
    for (int i = 1; i <= t; i++)
    {
        cout << "Case #" << i << ": ";
        solve();
    }
}
```


***
### J:[Serval and Essay](https://ac.nowcoder.com/acm/contest/33186/J)