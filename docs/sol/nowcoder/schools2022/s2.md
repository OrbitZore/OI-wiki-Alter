### A:[Falfa with Polygon](https://ac.nowcoder.com/acm/contest/33187/A)


***

### E:[Falfa with Substring](https://ac.nowcoder.com/acm/contest/33187/E)


***

### H:[Take the Elevator](https://ac.nowcoder.com/acm/contest/33187/H)

#### LyFive
##### 标签
贪心;模拟

##### 题意
现在有k个人准备坐电梯，但电梯相同时刻只能容纳$m$人并且只能从第一层到达某层，再从某层回到第一层。上升/下降速度为1层/单位时长，现求把k个人都送到目的位置花费多少单位时长。

##### 思路
考虑电梯的行动轨迹，不难发现电梯接送的时候应该尽可能先把未被接送的最高层人接送完成，这样整体花费的时间最少。
首先把需要接送的人分为上升和下降人群，在每一轮上升下降过程优先接送可能到达的最高层，每轮次的时间消耗为$2t-2$。不断模拟轮次删除即可算出答案。
考虑模拟过程中，维护电梯人数状态，为了方便考虑我们可以把上升人群$由x->y(x < y)$直接转换成下降情况$y -> x(x < y)$同类进行考虑。
设正在电梯的人的集合为$T$，电梯人群目标下降的最高楼层为$x_{max}$。
首先，对不同人群按照$y$第一关键字排序，每轮比较上升人群和下降人群最大的$y$更新$ans$。然后每一轮分开维护上升和下降的电梯状态，每次有人需要上电梯时检查电梯是否满员，即集合大小$|T| < m$或$x_{max} > y_i$，若后者满足则表示下降过程有人出了电梯并删除$x_{max}$加入$x_i$继续维护电梯状态。最终，上升和下降人群全部接送完毕即可。

??? note "参考代码"
    ```cpp
    --8<-- "docs/sol/code/nowcoder/schools2022_2_H.cpp"
    ```


***

### L:[Link with Level Editor I](https://ac.nowcoder.com/acm/contest/33187/L)

#### LyFive
##### 标签
dp;dp空间优化

##### 题意
某个游戏有n个世界，每个世界都是一张有向图。玩家起始在首个世界$w_i$的1号节点，每次可以选择不动或移动一步，随后穿梭到下一个世界$w_{i+1}$的当前节点。当穿梭所有世界结束后，到达$m$节点则游戏胜利。现在作者想从n个世界中选择最小的连续的世界$[w_i,w_j] (i \leq j)$作为这个游戏的某个关卡，要求至少存在一种获胜方案，求连续的世界集合最小的大小。

##### 思路
由于世界是连续穿梭，且每个世界只能走0/1步。不难发现后面出现的世界是对前面的扩展，即枚举前置世界的情况无后效性。为此考虑要求集合最小，则每次加入一个新的世界找到所需最近的世界。定义状态$dp[i][j]$为只使用前$i$个世界以其为起点能够到达节点$j$编号最大的世界。不难发现，对于第$i$个世界若存在$1->z$的路径则$dp[i][z] = i$,若存在$x->y(x \neq 1)$的路径，则$dp[i][y] = min(dp[i-1][x],dp[i][y])$。同时状态第一维可以用滚动数组优化。最终输出$dp[n][m]$即可。

??? note "参考代码"
    ```cpp
    --8<-- "docs/sol/code/nowcoder/schools2022_2_L.cpp"
    ```

