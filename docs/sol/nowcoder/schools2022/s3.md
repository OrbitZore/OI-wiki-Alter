### C:[Concatenation](https://ac.nowcoder.com/acm/contest/33188/C)
#### LyFive
##### 标签
trie树;exkmp;dfs;空间优化

##### 题意
给定$n$个字符串，求$n$个字符串连接后字典序最小的$S$。

##### 思路
最简单的贪心思路能够想到，若$a$的拼接顺序在$b$的前面，则应满足$a+b \leq b + a$。为此最简单的方案是以此为关键字排序，时间复杂度为$O(|S|logn)$。为将复杂度降低至线性，可以考虑如果排序$a,b$。利用贪心思想，①若$a$不是$b$的前缀$(|a| <= |b|)$，则应直接比较$a,b$的字典序，将字典序小的放在前面；②若$a$是$b$的前缀则利用$exkmp$O(1)进行比较。因此具体方案如下：构造$trie$树，根据$trie$树各串的$dfs$序确定①排序，此时目标字符串$str$的前缀集合$STR$已经排序完成，通过比较$str$与每一个存在的前缀$STR_i$的排序关系进行插入排序即可。且不难证明，设所有排在$str$前面的前缀集合为$A$，排在$str$后面的前缀集合为$B$。则$B$集合一定是连续的，即不存在元素$a_i \in A$在$b_j,str$之间。因为$a_i < str,且b_j > str 故顺序为a_i < str < b_j$。因此，核心实现难度为使用$exkmp$比较$str$与$STR$的大小关系。
令$str = Sa$通过$exkmp$我们探讨$Sa$与前缀$S$的排序关系：首先，$exkmp$的$Z$数组$Z[i]$代表以$i$下标开始的后缀与原字符串的最长公共前缀长度。我们将$Sa与S$拼接可得到$SaS$与$SSa$。比较$SaS$与$SSa$的字典序，若前者字典序小则前缀$S$应属于$B$集合，否则属于$A$集合。
比较下面两种情况$Z[|S|]| = |a|$，$Z[|S|] < |a| $
![imges](images/s3-C.png)
1. 左边：$Z[|S|] = |a|$，此时红线左部分一致，若要比较$SaS,SSa$的字典序关系应为红线右半部分字典序关系。此时红线位置上方相对于$Sa$下标为$|a|$，下方相对于$Sa$下标为0。再次利用$exkmp$的$Z$数组，得到$Z[|a|]$为此只需比较$Sa[Z|a|]$与$Sa[|a|+Z[|a|]]$的大小关系即可。
2. 右边：$Z[|S|] \neq |a|$，此时红线上方相对于$Sa$下标为$|S|+Z[|S|]$。下方相对于$Sa$下标为$Z[|S|]$，同理比较$Sa[|S|+Z[|S|]$与$Sa[|S|]$的大小关系即可。


??? note "参考代码"
    ```cpp
    --8<-- "docs/sol/code/nowcoder/schools2022_3_C.cpp"
    ```



***

### F:[Fief](https://ac.nowcoder.com/acm/contest/33188/F)



***

### H:[Hacker](https://ac.nowcoder.com/acm/contest/33188/H)

#### LyFive
##### 标签
$sam$;线段树

##### 题意
给定一个字符串$A$，和一个权值数组$v,|v| =m$。每次询问输入一个字符串$B,|B| = m$，$B_i$的权值为$v_i$现求字符串$B$与$A$的所有公共子串的权值和最大为多少。

##### 思路
首先通过$sam$可以遍历一遍$B$就可以得到所有与$A$匹配的最长子串，为此问题就转换为给定一个数组，求最大数组区间和。对于最大数组区间和，利用前缀和枚举选定一个右边界通过线段树找到最小的左边界就可以得到。而时间复杂度分析可以得到，匹配的子串涉及的长度最多为$m$，保证每个右边界最多访问一次，每次查找左边界为$logn$，为此时间复杂度为$O(kmlogn)$。考虑实现细节，如何保证$sam$匹配得到最长子串。利用$sam$的$endpos$性质，存储连续后缀长度信息(如:$ababa,baba,aba$为连续后缀)。每次利用$sam$遍历$B$串匹配得到最长串更新$ans$，并删除最长串的第一个字符即下一个连续后缀，判断该连续后缀是否属于当前状态即后缀长度是否大于等于$endpos$状态集最小长度，若满足则当前匹配状态不变，否则通过$Link$边进入$endpos$的下一个连续后缀。为此就能保证每次匹配可以得到最长匹配子串。再记录右边界更新情况，保证每个右边界只查询一次即可。

??? note "参考代码"
    ```cpp
    --8<-- "docs/sol/code/nowcoder/schools2022_3_H.cpp"
    ```

***

### J:[Journey](https://ac.nowcoder.com/acm/contest/33188/J)

#### LyFive
##### 标签
$bfs$;最短路

##### 题意
给定$n$个十字路口，右转不会遇见红灯，其他方向都会遇到一次红灯。初始在$s2->s1$的路上，求到达$t2->t1$的路径上，最少遇见的多少红灯。

##### 思路
不难发现，每次选定一个路径遇见的红灯次数为$0/1$，为此可以直接使用$bfs$进行遍历更新答案。设图为$c[i][j]$表示节点$i$通过第$j$条边达到的位置，处理时可以用队列$q$存储右转同层路径使用栈/数组/队列$s$存储下一层路径即可。维护过程中需要注意建图方式，若当前路径为$(t2,t1)$需要找到$t2 -> t1$的边位置$pos$，右转则表示到达边$t1 -> c[t2][pos + 1]$，枚举其他边则表示$t1 -> c[t2][pos+i] (2 < i \leq 4)$。

??? note "参考代码"
    ```cpp
    --8<-- "docs/sol/code/nowcoder/schools2022_3_J.cpp"
    ```

***